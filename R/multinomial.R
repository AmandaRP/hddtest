
#' Test two multinomial datasets
#'
#' Peforms the test for two multinomial vectors
#' testing \eqn{H_o:} the underlying multinomial probability vectors are the same
#' vs. \eqn{H_1:} they are different.
#'
#' @param x,y Integer vectors (or matrices/dataframes containing multiple integer vector observations as rows).
#' \code{x} and \code{y} must be the same type and dimension. If \code{x} and \code{y} are matrices (or dataframes), the ith row
#' of \code{x} will be tested against the \eqn{i^th} row of \code{y} for all \eqn{i} in 1..nrow(x).
#' @return The \code{statistic} and its associated \code{p-value}.
#' If \code{x} and \code{y} are either matrices or dataframes, a \code{statistic} and \code{p-value} will be returned
#' for each row.
#' @seealso
#' Amanda Plunkett & Junyong Park (2018) \emph{Two-Sample Test for Sparse High Dimensional Multinomial Distributions}, TEST, \url{https://doi.org/10.1007/s11749-018-0600-8}
#' @examples
#' #Generate two vectors from the same distributions:
#' data <- genMultinomialData(sample_size=1)
#'
#' #Perform test:
#' multinom.test(x=data[[1]],y=data[[2]])
#'
#' #Generate 1000 vectors from each of two different distributions:
#' data <- genMultinomialData(null_hyp=FALSE,sample_size=1000)
#'
#' #Perform test (compare the ith row of x to the ith row of y for all rows):
#' result <- multinom.test(x=data[[1]],y=data[[2]])
#' #Return power of test at the alpha=0.05 level:
#' alpha <- 0.05
#' mean(result$pvalue<alpha)

multinom.test <- function(x,y){

  #check that x and y are the same structures:
  if(class(x) != class(y)){
    stop("x and y must be the same class")
  }

  #Check that the same number of categories are defined for x and y:
  if( ((is.data.frame(x) || is.matrix(x)) && any(dim(x) != dim(y))  ) ||
      ((is.vector(x)     || is.array(x))  && length(x) != length(y)) ){
    stop("x and y should have the same number of categories
     (i.e. same length if x and y are vectors or same number of columns if
         x and y are matrices or dataframes)")
  }


  if((is.data.frame(x) || is.matrix(x)) && nrow(x)>1  ){
    multipleSamples <- TRUE
  }else{
    multipleSamples <- FALSE
  }

  data <- list(x,y)

  p_hat <- list() #p_hat is each element divided by the row sum.
  sum <- 0
  n <- list()

  for(g in 1:2){ #Two groups

    if(multipleSamples){
      n[[g]] <- rowSums(data[[g]])
    }else{
      n[[g]] <- sum(data[[g]])
    }

    p_hat[[g]] <- data[[g]]/n[[g]]
  }

  D <- (p_hat[[1]]-p_hat[[2]])^2 - p_hat[[1]]/n[[1]] - p_hat[[2]]/n[[2]]

  if(multipleSamples){
    stat_numerator <- rowSums(D)
  }else{
    stat_numerator <- sum(D)
  }


  if(multipleSamples){
    D_var <- rep(0,nrow(x))
    for(g in 1:2){
      D_var <- D_var + (2/n[[g]]^2)* rowSums(p_hat[[g]]^2 + p_hat[[g]]/n[[g]])
    }
    #integer overflow:
    stat_var <- D_var + ( 4 * rowSums(p_hat[[1]] * p_hat[[2]]) /n[[1]] ) /n[[2]]
    #  }
  }else{
    D_var <- 0
    for(g in 1:2){
      D_var <- D_var + (2/n[[g]]^2)* sum(p_hat[[g]]^2 + p_hat[[g]]/n[[g]])
    }
    #integer overflow:
    stat_var <- D_var + ( 4 * sum(p_hat[[1]] * p_hat[[2]]) /n[[1]] ) /n[[2]]
  }

  stat_denominator <- sqrt(stat_var)

  stat <- stat_numerator/stat_denominator

  stat_pvalue <- 1-pnorm(stat)

  return(list(statistic=stat,pvalue=stat_pvalue))
}





#################### Generate multinomial data: ###################

#' Generate multinomial data
#'
#' Generate two sets of multinomially distributed vectors using \code{rmultinom}. Useful for hypothesis testing simulations.
#' Three different experiments with different probability vectors are available in addition to user-specified probability vector \code{p}:
#' \itemize{
#' \item Experiment 1: \eqn{p_{1i} = \frac{1/i^\alpha}{\sum_1^k 1/i^\alpha}}. When the \code{null_hyp} parameter is FALSE, the probability vector for the
#'       2nd group is generated by switching the position of 1st and \eqn{m^th} entries.
#' \item Experiment 2: \eqn{p_{1i} = 1/k}. When the \code{null_hyp} parameter is FALSE, \eqn{p_{2i} = 0} for \eqn{i \in [1,b]} and \eqn{p_{2,b+1}= \sum_{1}^{b+1} p_{1i} = (b+1)/k }.
#' \item Experiment 3: \eqn{p_{1i} = 1/k}. When the \code{null_hyp} parameter is FALSE, \eqn{p_{2i} = 0} for \eqn{i \in [1,b]} and \eqn{p_{2i} = 1/(k âˆ’ b)}  for \eqn{i > b}.
#' }
#'
#' @param null_hyp logical; if TRUE, generate data using the same distribution. Default value is TRUE.
#' @param p An optional 2 by \eqn{k} matrix specifying the probabilities of the \eqn{k} categories for each of the two groups.
#' Each row of \code{p} must sum to 1.
#' If defined, the rest of the function parameters will not be used. Default value is NULL.
#' @param k Integer representing dimension (number of categories). Default 2000.
#' @param n Vector of length 2 specifying the parameter of each multinomial distribution used to define the
#' total number of objects that are put into \eqn{k} bins in the typical multinomial experiment.
#' @param sample_size Integer specifying the number of random vectors to generate for each of the two groups.
#' @param expID Experiment number 1-3. Default is 1.
#' @param alpha Number between 0 and 1. Used for experiment 1. Default is 0.45.
#' @param m Integer between 2 and \eqn{k}. Used in experiment 1 for the alternative hypothesis. Default is 50.
#' @param numzero Integer between 1 and \eqn{k}-1. Used in experiments 2 and 3 for the alternative hypothesis. Default is 50.
#' @param ... Additional parameters.
#' @return A list containing two matrices each having dimension \code{sample_size} by \eqn{k}.
#' @examples
#' #Generate data when the null hypothesis is FALSE:
#' X <- genMultinomialData(FALSE)
#'
#' #Dimension of the two generated datasets:
#' lapply(X,dim)
#'
#' #Proportion of entries less than 5 in the first dataset:
#' sum(X[[1]]<5)/(nrow(X[[1]])*ncol(X[[1]]))
genMultinomialData <- function(null_hyp=TRUE,p=NULL,k=2000,n=c(8000,8000),sample_size=30,expID=1,alpha=0.45,m=50,numzero=50,...){

  #Generate p if it is not given
  if(is.null(p)){
    p <- matrix(NA,2,k)
    sum <- 0

    #First group:
    if(expID==1){  #inverse or shift
      p[1,] <- (1/(1:k)^alpha)
      p[1,] <- p[1,]/sum(p[1,])
    }else if(expID==2 | expID==3){  #uniform
      p[1,] <- rep(1/k,times=k)
    }

    if(null_hyp){ #null hypothesis is TRUE
      p[2,] <- p[1,]
    }else{ #null hypothesis is FALSE
      if(expID==1){ #inverse
        #Flip order two entries:
        p[2,] <- p[1,]
        if(is.null(w)){
          w <- 1
        }
        p[2,w] <- p[1,m]
        p[2,m] <- p[1,w]

      }else if(expID==2){ #uniform-spike

        #Zero some out and add to a single probability (exp 3):
        p[2,] <- p[1,]
        p[2,numzero+1] <- sum(p[2,1:(numzero+1)])
        p[2,1:numzero] <- 0

      }else if(expID==3){ #uniform
        #Zero some out and make the rest uniform:
        num_nonzero = k-numzero
        p[2,1:num_nonzero] <- rep(1/num_nonzero,times=num_nonzero)
        p[2,(num_nonzero+1):k] <- 0

      }

    }
  }else{ #check to verify that p is 2xk and the rows sum to 1
    if(nrow(p) != 2){
      stop("Error: p must be a 2 by k dimensional matrix.")
    }
    if(any(rowSums(p) != 1)){
      stop("Error: Row sums of p must be equal to 1.")
    }
  }

  #Generate data
  X <- list()
  for(g in 1:2){
    X[[g]] <- t(rmultinom(sample_size,n[g],p[g,]))
  }

  return(X)
}
